package com.dqops.metadata.sources.fileformat;

import com.dqops.metadata.basespecs.AbstractSpec;
import com.dqops.metadata.id.ChildHierarchyNodeFieldMap;
import com.dqops.metadata.id.ChildHierarchyNodeFieldMapImpl;
import com.dqops.metadata.id.HierarchyNodeResultVisitor;
import com.dqops.utils.serialization.IgnoreEmptyYamlSerializer;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonPropertyDescription;
import com.fasterxml.jackson.databind.PropertyNamingStrategies;
import com.fasterxml.jackson.databind.annotation.JsonNaming;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import lombok.EqualsAndHashCode;
import lombok.experimental.FieldNameConstants;

import java.util.List;

/**
 * Parquet file format specification for querying data in the parquet format files.
 */
@JsonInclude(JsonInclude.Include.NON_NULL)
@JsonNaming(PropertyNamingStrategies.SnakeCaseStrategy.class)
@EqualsAndHashCode(callSuper = true)
@FieldNameConstants
public class ParquetFileFormatSpec extends AbstractSpec {

    private static final ChildHierarchyNodeFieldMapImpl<ParquetFileFormatSpec> FIELDS = new ChildHierarchyNodeFieldMapImpl<>(AbstractSpec.FIELDS) {
        {
        }
    };

    @JsonPropertyDescription("Parquet files generated by legacy writers do not correctly set the UTF8 flag for strings, causing string columns to be loaded as BLOB instead. Set this to true to load binary columns as strings.")
    @JsonInclude(JsonInclude.Include.NON_EMPTY)
    @JsonSerialize(using = IgnoreEmptyYamlSerializer.class)
    private Boolean binaryAsString;

    @JsonPropertyDescription("Whether or not an extra filename column should be included in the result.")
    @JsonInclude(JsonInclude.Include.NON_EMPTY)
    @JsonSerialize(using = IgnoreEmptyYamlSerializer.class)
    private Boolean filename;

    @JsonPropertyDescription("Whether or not to include the file_row_number column.")
    @JsonInclude(JsonInclude.Include.NON_EMPTY)
    @JsonSerialize(using = IgnoreEmptyYamlSerializer.class)
    private Boolean fileRowNumber;

    @JsonPropertyDescription("Whether or not to interpret the path as a hive partitioned path.")
    @JsonInclude(JsonInclude.Include.NON_EMPTY)
    @JsonSerialize(using = IgnoreEmptyYamlSerializer.class)
    private Boolean hivePartitioning;

    /**
     * Formats the table options to be used in SQL query. The set (non null) options are added only.
     * @param filePathList The names of files with data.
     * @return The formatted source table with the options.
     */
    public String buildSourceTableOptionsString(List<String> filePathList){
        TableOptionsFormatter tableOptionsFormatter = new TableOptionsFormatter("read_parquet", filePathList);
        tableOptionsFormatter.formatValueWhenSet(Fields.binaryAsString, binaryAsString);
        tableOptionsFormatter.formatValueWhenSet(Fields.filename, filename);
        tableOptionsFormatter.formatValueWhenSet(Fields.fileRowNumber, fileRowNumber);
        tableOptionsFormatter.formatValueWhenSet(Fields.hivePartitioning, hivePartitioning);
        return tableOptionsFormatter.toString();
    }

    /**
     * Returns the binary as string option state.
     * @return The binary as string option state.
     */
    public Boolean getBinaryAsString() {
        return binaryAsString;
    }

    /**
     * Sets binary as string option state.
     * @param binaryAsString The binary as string option state.
     */
    public void setBinaryAsString(Boolean binaryAsString) {
        this.binaryAsString = binaryAsString;
    }

    /**
     * Returns whether or not an extra filename column should be included in the result.
     * @return The filename option state.
     */
    public Boolean getFilename() {
        return filename;
    }

    /**
     * Sets that an extra filename column should be included in the result.
     * @param filename The filename option state.
     */
    public void setFilename(Boolean filename) {
        this.filename = filename;
    }

    /**
     * Returns whether or not to include the file_row_number column.
     * @return The file row number option state.
     */
    public Boolean getFileRowNumber() {
        return fileRowNumber;
    }

    /**
     * Sets whether or not to include the file_row_number column.
     * @param fileRowNumber The file row number option state.
     */
    public void setFileRowNumber(Boolean fileRowNumber) {
        this.fileRowNumber = fileRowNumber;
    }

    /**
     * Returns whether or not to interpret the path as a hive partitioned path.
     * @return The hive partitioning option state.
     */
    public Boolean getHivePartitioning() {
        return hivePartitioning;
    }

    /**
     * Sets to interpret the path as a hive partitioned path.
     * @param hivePartitioning Hive partitioning option state.
     */
    public void setHivePartitioning(Boolean hivePartitioning) {
        this.hivePartitioning = hivePartitioning;
    }

    @Override
    protected ChildHierarchyNodeFieldMap getChildMap() {
        return FIELDS;
    }

    @Override
    public <P, R> R visit(HierarchyNodeResultVisitor<P, R> visitor, P parameter) {
        return visitor.accept(this, parameter);
    }

}
